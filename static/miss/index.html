<!DOCTYPE html>
<meta charset="utf-8">
<style>
.state-data { fill: #f4f4f4}
.state-boundary { stroke: #fff;
                  fill-opacity: 0;
                  stroke-linejoin: round;
                  stroke-width: 2px; }
.river { fill-opacity: 0;
         stroke-linejoin: round;}
.mississippi { stroke: #95DEF8;
               stroke-width: 2.5px;}
.tributary { stroke: #C7EBF8;
             stroke-width: 1.3px;}
.canoe-point { fill-opacity: 0.5}
.gradient { fill-opacity: 0.35}
.guide-lines { stroke: #999;
               stroke-linecap: round}
.place-label { font-size : 12px;
               fill: #777;}
.city { fill: #777;}
</style>
<p>
    <select form="display_var" id="display_var" autofocus> 
        <option value="alt">Altitude</option> 
        <option value="speed">Speed</option> 
        <option value="heading" selected>Heading</option> 
        <option value="climb">Climb</option> 
        <option value="accel_x">X Acceleration</option>
        <option value="accel_y">Y Acceleration</option> 
        <option value="accel_z">Z Acceleration</option> 
        <option value="gyro_x">X Gyroscope</option> 
        <option value="gyro_y">Y Gyroscope</option> 
        <option value="gyro_z">Z Gyroscope</option> 
        <option value="air_tmp">Air Temperature</option> 
        <option value="air_gas">Air Gas</option> 
        <option value="air_hmd">Air Humidity</option> 
        <option value="ar_prss">Air Pressure</option> 
        <option value="wtr_tmp">Water Temperature</option> 
    </select> 
</p>
<body>
<script src="//d3js.org/d3.v4.min.js" charset="utf-8"></script>
<script src="//d3js.org/topojson.v2.min.js"></script>
<script src="//d3js.org/d3-scale-chromatic.v0.3.min.js"></script>
<script src="https://d3js.org/d3-queue.v2.min.js"></script>
<script src="https://d3js.org/d3-scale.v3.min.js"></script>
<script src="https://d3js.org/d3-array.v2.min.js"></script>
<script>
    var width = 450,
        height = 800;

    var grad_top = 75,
        grad_bottom = 725,
        grad_left = 75,
        grad_width = 20;

    var sym_log_transform_vars = ["accel_x", "accel_y", "accel_z",
                                  "gyro_x", "gyro_y", "gyro_z",
                                  "air_gas"]

    function index_to_y(index, chunk) {
        return grad_top +((index + 1500*(chunk-1))/(25432 + 1500*4) )*(grad_bottom-grad_top);
    }

    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);
    
    var colorScale = d3.scaleSequential(d3.interpolateViridis)
        .domain([0, 360])

    var projection = d3.geoAlbersUsa()
        .scale(2000)
        .translate([width / 4, height / 2]);

    var path = d3.geoPath()
        .projection(projection)
        .pointRadius(3);

    d3.queue()
        .defer(d3.json, "miss_basin_data.json")
        .defer(d3.csv, "small_clean_legs_non_geom.csv")
        .defer(d3.json, "guide_lines.json")
        .await(ready);

    function ready(error, 
                   miss_basin_data, 
                   small_clean_legs_non_geom,
                   guide_lines) {

        var line = d3.line()
            .x(d => d.x)
            .y(d => d.y)

        svg.append("path")
            .datum(topojson.feature(miss_basin_data, miss_basin_data.objects.state_data))
            .attr("class", "state-data")
            .attr("d", path);

        svg.append("path")
            .datum(topojson.mesh(miss_basin_data, miss_basin_data.objects.state_data, (a, b) => a !== b ))
            .attr("d", path)
            .attr("class", "state-boundary");


        svg.selectAll(".river")
            .data(topojson.feature(miss_basin_data, miss_basin_data.objects.miss_basin_rivers_10).features)
            .enter().append("path")
            .attr("d", path)
            .attr("class", d => d.properties.name === "Mississippi" ? "river " + "mississippi":"river " + "tributary");

        svg.append("path")
            .datum(topojson.feature(miss_basin_data, miss_basin_data.objects.city_data))
            .attr("d", path)
            .attr("class", "city");

        svg.selectAll(".canoe-point")
            .data(topojson.feature(miss_basin_data, miss_basin_data.objects.small_clean_legs).features)
            .enter().append("path")
            .attr("class", "canoe-point")
            .attr("d", path)
            .attr("fill", d => colorScale(d.properties.heading));

        svg.selectAll(".gradient")
            .data(small_clean_legs_non_geom)
            .enter()
            .append("rect") 
            .attr("x", grad_left)
            .attr("y", d => index_to_y(parseInt(d.index), parseInt(d.chunk)))
            .attr("fill", d => colorScale(d.heading))
            .attr("width", grad_width)
            .attr("height", 10)
            .attr("class", "gradient");

        svg.selectAll(".guide-lines")
            .data(guide_lines)
            .enter().append("path")
            .attr("class", "guide-lines")
            .attr("d", line)

        svg.selectAll(".city-label")
            .data(topojson.feature(miss_basin_data, miss_basin_data.objects.city_data).features)
            .enter().append("text")
            .attr("class", "place-label")
            .attr("transform", d => "translate(" + projection(d.geometry.coordinates) + ")")
            .attr("dy", "-0.5em")
            .attr("dx", "0.5em")
            .text(d => d.properties.name);

        d3.select("#display_var").on("input", function() {
            update(this.value, small_clean_legs_non_geom);
        })
    };

    function update(value, data) {
        var median = d3.median(data, d => parseInt(d[value])); 
        var extent = d3.extent(data, d => parseInt(d[value]));

        colorScale = sym_log_transform_vars.includes(value) ?
                        d3.scaleSequentialSymlog(d3.interpolateViridis).domain(extent) :
                        d3.scaleSequential(d3.interpolateViridis).domain(extent);

        svg.selectAll(".gradient")
            .attr("fill", d => isNaN(parseInt(d[value])) ? 'grey' : colorScale(parseInt(d[value])));

        svg.selectAll(".canoe-point")
            .attr("fill", d => isNaN(parseInt(d.properties[value])) ? 'grey' : colorScale(parseInt(d.properties[value])));

    }
</script>